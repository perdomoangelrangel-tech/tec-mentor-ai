/** MathJSON 0.30.2 */
    (function(global,factory){typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'],factory):(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MathJson = {}));})(this, (function (exports) { 'use strict';
var MathJson = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/math-json.ts
  var math_json_exports = {};
  __export(math_json_exports, {
    dictionaryFromExpression: () => dictionaryFromExpression,
    isFunctionObject: () => isFunctionObject,
    isStringObject: () => isStringObject,
    isSymbolObject: () => isSymbolObject,
    mapArgs: () => mapArgs,
    operand: () => operand,
    operator: () => operator,
    stringValue: () => stringValue,
    symbol: () => symbol,
    version: () => version
  });

  // src/math-json/utils.ts
  function isSymbolObject(expr) {
    return expr !== null && typeof expr === "object" && "sym" in expr;
  }
  function isStringObject(expr) {
    return expr !== null && typeof expr === "object" && "str" in expr;
  }
  function isDictionaryObject(expr) {
    return expr !== null && typeof expr === "object" && "dict" in expr && typeof expr.dict === "object" && !Array.isArray(expr.dict) && expr.dict !== null;
  }
  function isFunctionObject(expr) {
    return expr !== null && typeof expr === "object" && "fn" in expr && Array.isArray(expr.fn) && expr.fn.length > 0 && typeof expr.fn[0] === "string";
  }
  function stringValue(expr) {
    if (expr === null || expr === void 0) return null;
    if (typeof expr === "object" && "str" in expr) return expr.str;
    if (typeof expr !== "string") return null;
    if (expr.length >= 2 && expr.at(0) === "'" && expr.at(-1) === "'")
      return expr.substring(1, expr.length - 1);
    if (matchesNumber(expr) || matchesSymbol(expr)) return null;
    return expr;
  }
  function operator(expr) {
    if (Array.isArray(expr)) return expr[0];
    if (expr === null || expr === void 0) return "";
    if (isFunctionObject(expr)) return expr.fn[0];
    return "";
  }
  function operands(expr) {
    if (Array.isArray(expr)) return expr.slice(1);
    if (expr !== void 0 && isFunctionObject(expr)) return expr.fn.slice(1);
    return [];
  }
  function operand(expr, n) {
    if (Array.isArray(expr)) return expr[n] ?? null;
    if (expr === null || !isFunctionObject(expr)) return null;
    return expr.fn[n] ?? null;
  }
  function nops(expr) {
    if (expr === null || expr === void 0) return 0;
    if (Array.isArray(expr)) return Math.max(0, expr.length - 1);
    if (isFunctionObject(expr)) return Math.max(0, expr.fn.length - 1);
    return 0;
  }
  function symbol(expr) {
    if (typeof expr === "string" && matchesSymbol(expr)) {
      if (expr.length >= 2 && expr.at(0) === "`" && expr.at(-1) === "`")
        return expr.slice(1, -1);
      return expr;
    }
    if (expr === null || expr === void 0) return null;
    if (isSymbolObject(expr)) return expr.sym;
    return null;
  }
  function keyValuePair(expr) {
    const h = operator(expr);
    if (h === "KeyValuePair" || h === "Tuple" || h === "Pair") {
      const [k, v] = operands(expr);
      const key = stringValue(k);
      if (!key) return null;
      return [key, v ?? "Nothing"];
    }
    return null;
  }
  function dictionaryFromExpression(expr) {
    if (expr === null) return null;
    if (isDictionaryObject(expr)) return expr;
    const kv = keyValuePair(expr);
    if (kv) return { [kv[0]]: kv[1] };
    if (operator(expr) === "Dictionary") {
      const result = {};
      const ops = operands(expr);
      for (let i = 1; i < nops(expr); i++) {
        const kv2 = keyValuePair(ops[i]);
        if (kv2) result[kv2[0]] = kv2[1];
      }
      return result;
    }
    return null;
  }
  function mapArgs(expr, fn) {
    let args = null;
    if (Array.isArray(expr)) args = expr;
    if (isFunctionObject(expr)) args = expr.fn;
    if (args === null) return [];
    let i = 1;
    const result = [];
    while (i < args.length) {
      result.push(fn(args[i]));
      i += 1;
    }
    return result;
  }
  function matchesNumber(s) {
    return /^(nan|oo|\+oo|-oo|infinity|\+infinity|-infinity)$/i.test(s) || /^[+-]?(0|[1-9][0-9]*)(\.[0-9]+)?(\([0-9]+\))?([eE][+-]?[0-9]+)?$/.test(s);
  }
  function matchesSymbol(s) {
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s) || s.length >= 2 && s[0] === "`" && s[s.length - 1] === "`";
  }

  // src/math-json.ts
  var version = "0.30.2";
  return __toCommonJS(math_json_exports);
})();
Object.assign(exports, MathJson); Object.defineProperty(exports, '__esModule', { value: true });}));
